# install
berw install mongodb
# launch
mongo
# Tutorial source: https://metanit.com/nosql/mongodb/2.2.php
#  в качестве текущей БД будет установлена БД info.
use info
# вывести названия всех имеющихся бд на консоль:
show dbs
# какая бд используется в текущей момент
db
# список всех коллекций в текущей бд с помощью команды
show collections
# получить статистику по текущей базе данных
db.stats()
# статистику по коллекции users:
db.users.stats()
# добавление документов:
#insertOne(): добавляет один документ
#insertMany(): добавляет несколько документов
#insert(): может добавлять как один, так и несколько документов
db.users.insertOne({"name": "Tom", "age": 28, languages: ["english", "spanish"]})
#чтобы убедиться, что документ в бд, мы его выводим функцией find.
db.users.find()
# Чтобы вывести в более читабельном виде добавим метод pretty():
db.users.find().pretty()
# Если надо добавить ряд документов, то мы можем воспользоваться методом insertMany():
db.users.insertMany([{"name": "Bob", "age": 26, languages: ["english", "frensh"]},
{"name": "Alice", "age": 31, languages:["german", "english"]}])
# третий метод - insert() демонстрирует более универсальный способ добавления документов.
db.users.insert({"name": "Tom", "age": 28, languages: ["english", "spanish"]})
# После его вызова на консоль выводится количество добавленных записей:
WriteResult({ "nInserted" : 1 })
# еще один способ добавления в бд документа, который включает два этапа: определение документа (document = ( { ... } )) и собственно его добавление:
document=({"name": "Bill", "age": 32, languages: ["english", "french"]})
db.users.insert(document)
# можно с помощью функции db.users.find() убедиться, что документ попал в бд.
db.users.find()
# Для загузки файла в текущую базу данных применяется функция load(), в которую в качестве параметра передается путь к файлу:
#load("D:/Users/pauline/Documents/Python/Script-001-Hist.py")
load("D:/users.js")
# Для вывода документов в более удобном наглядном представлении
db.users.find().pretty()
# Выведем все документы, в которых name=Tom:
db.users.find({name: "Tom"})
# вывести те объекты, у которых name=Tom и одновременно age=28
db.users.find({name: "Tom", age: 28})
# выводит все документы, у которых в массиве languages есть english:
db.users.find({languages: "english"})
# Усложним запрос и получим те документы, у которых в массиве languages одновременно два языка:
db.users.find({languages: ["english", "french"]})
# выведем только порцию информации, например, значения полей "age" у всех документов, в которых name=Tom:
db.users.find({name: "Tom"}, {age: 1})
# использование регулярных выражений. Например, найдем все документы, в которых значение ключа name начинается с буквы T:
db.users.find({name:/T\w+/i})
# функция limit. Она задает максимально допустимое количество получаемых документов. Количество передается в виде числового параметра. Например, ограничим выборку тремя документами:
db.users.find().limit(3)
# если мы хотим произвести выборку не сначала, а пропустив какое-то количество документов? В этом нам поможет функция skip. Например, пропустим первые три записи:
db.users.find().skip(3)
# мы можем совмещать все эти функции в одной цепочке:
db.users.find().sort({name: 1}).skip(3).limit(3)
# С помощью функции count() можно получить число элементов в коллекции:
db.users.count()
# Можно группировать параметры поиска и функцию count, чтобы подсчитать, сколько определенных документов, например, у которых name=Tom:
db.users.find({name: "Tom"}).count()
# мы можем создавать цепочки функций, чтобы конкретизировать условия подсчета:
db.users.find({name: "Tom"}).skip(1).count(true)
# найти только уникальные различающиеся значения для одного из полей документа. Для этого мы можем воспользоваться функцией distinct:
db.users.distinct("name")
# Группировка и метод group. Использование метода group аналогично выражению GROUP BY в SQL.
db.users.group ({key: {name : true}, initial: {total : 0}, reduce : function (curr, res){res.total += 1}})
# $lt (меньше чем)
db.users.find ({age: {$lt : 30}})
# $gt (больше чем)
db.users.find ({age: {$gt : 30}})
# $eq (равно)
db.users.find ({age: {$eq : 28}})
# найти все объкты со значением поля age больше 30, но меньше 50. В этом случае мы можем комбинировать два оператора:
db.users.find ({age: {$gt : 30, $lt: 50}})
# найдем пользователей, возраст которых НЕ равен 22:
db.users.find ({age: {$ne : 22}})
# $nin определяет массив значений, которые не должно иметь поле документа
db.users.find ({age: {$nin : [22, 32]}})
# $or: соединяет два условия, и документ должен соответствовать одному из этих условий
db.users.find ({$or : [{name: "Tom"}, {age: 32}]})
# выбираем все документы, где name="Tom" или поле age имеет значение от 30 и выше.
db.users.find ({$or : [{name: "Tom"}, {age: {$gte:30}}]})
# Оператор $all определяет массив возможных выражений и требует, чтобы документы имели весь определяемый набор выражений.
db.users.find ({languages: {$all : ["english", "french"]}})
# Оператор $elemMatch позволяет выбрать документы, в которых массивы содержат элементы, попадающие под определенные условия. Например, пусть в базе данных будет коллекция, которая содержит оценки пользователей по определенным курсам. Добавим несколько документов:
db.grades.insertMany([{student: "Tom", courses:[{name: "Java", grade: 5}, {name: "MongoDB", grade: 4}]},
{student: "Alice", courses:[{name: "C++", grade: 3}, {name: "MongoDB", grade: 5}]}])
# Теперь найдем студентов, которые для курса MongoDB имеют оценку выше 3:
db.grades.find({courses: {$elemMatch: {name: "MongoDB", grade: {$gt: 3}}}})
# Оператор $size используется для нахождения документов, в которых массивы имеют число элементов, равным значению $size.
db.users.find ({languages: {$size:2}})
# Оператор $type извлекает только те документы, в которых определенный ключ имеет значение определенного типа
db.users.find ({age: {$type:"number"}})
# Оператор $regex задает регулярное выражение, которому должно соответствовать значение поля. Например, пусть поле name обязательно имеет букву "b":
db.users.find ({name: {$regex:"b"}})
# Обновление данных. Метод save
db.users.save({name: "Eugene", age : 29, languages: ["english", "german", "spanish"]})
# В качестве результата функция возвращает объект WriteResult. при успешном сохранении мы получим
WriteResult({"nInserted" : 1 })
# update. Более детальную настройку при обновлении предлагает функция update. Она принимает три параметра:
#query: принимает запрос на выборку документа, который надо обновить
#objNew: представляет документ с новой информацией, который заместит старый при обновлении
#options: определяет дополнительные параметры при обновлении документов. Может принимать два аргумента: upsert и multi.
db.users.update({name : "Tom"}, {name: "Tom", age : 25}, {upsert: true})
#Функция update() также возвращает объект WriteResult. Например:
WriteResult({"nMatched" : 1, "nUpserted": 0, "nModified": 1})
# Обновление отдельного поля. Часто не требуется обновлять весь документ, а только значение одного из его ключей. Для этого применяется оператор $set.
db.users.update({name : "Tom", age: 29}, {$set: {age : 30}})
# Если обновляемого поля в документе нет, до оно добавляется:
db.users.update({name : "Tom", age: 29}, {$set: {salary : 300}})
# В данном случае обновлялся только один документ, первый в выборке. Указав значение multi:true, мы можем обновить все документы выборки:
db.users.update({name : "Tom"}, {$set: {name: "Tom", age : 25}}, {multi:true})
# Для простого увеличения значения числового поля на определенное количество единиц применяется оператор $inc. Если документ не содержит обновляемое поле, то оно создается. Данный оператор применим только к числовым значениям.
db.users.update({name : "Tom"}, {$inc: {age:2}})
# Удаление поля
db.users.update({name : "Tom"}, {$unset: {salary: 1}})
# Если вдруг подобного ключа в документе не существует, то оператор не оказывает никакого влияния. Также можно удалять сразу несколько полей:
db.users.update({name : "Tom"}, {$unset: {salary: 1, age: 1}})
# updateOne и updateMany. Метод updateOne похож на метод update за тем исключением, что он обновляет только один документ.
db.users.updateOne({name : "Tom", age: 29}, {$set: {salary : 360}})
# Если надо обновить все документы, соответствующие к-л критерию, то применяется метод updateMany():
db.users.updateMany({name : "Tom"}, {$set: {salary : 560}})
# Обновление массивов. Оператор $push позволяет добавить еще одно значение к уже существующему. Например, если ключ в качестве значения хранит массив:
db.users.updateOne({name : "Tom"}, {$push: {languages: "russian"}})
# Используя оператор $each, можно добавить сразу несколько значений:
db.users.update({name : "Tom"}, {$push: {languages: {$each: ["russian", "spanish", "italian"]}}})
# Еще пара операторов позволяет настроить вставку. Оператор $position задает позицию в массиве для вставки элементов, а оператор $slice указывает, сколько элементов оставить в массиве после вставки.
db.users.update({name : "Tom"}, {$push: {languages: {$each: ["german", "spanish", "italian"], $position:1, $slice:5}}})
# Оператор $addToSet подобно оператору $push добавляет объекты в массив. Отличие состоит в том, что $addToSet добавляет данные, если их еще нет в массиве:
db.users.update({name : "Tom"}, {$addToSet: {languages: "russian"}})
# Удаление элемента из массива. Оператор $pop позволяет удалять элемент из массива:
db.users.update({name : "Tom"}, {$pop: {languages: 1}})
# Указывая для ключа languages значение 1, мы удаляем первый элемент с конца. Чтобы удалить первый элемент сначала массива, надо передать отрицательное значение:
db.users.update({name : "Tom"}, {$pop: {languages: -1}})
# Для удаления документов в MongoDB предусмотрен метод remove:
db.users.remove({name : "Tom"})
# Метод remove() возвращает объект WriteResult. При успешном удалении одного документа результат будет следующим: WriteResult({"nRemoved" : 2})
# Причем, как и в случае с find, мы можем задавать условия выборки для удаления различными способами (в виде регулярных выражений, в виде условных конструкций и т.д.):
db.users.remove({age: {$gt : 90}})
# Метод remove также может принимать второй необязательный параметр булевого типа, который указывает, надо удалять один элемент или все элементы, соответствующие условию. Если этот параметр равен true, то удаляется только один элемент. По умолчанию он равен false:
db.users.remove({name : "Tom"}, true)
# Чтобы удалить разом все документы из коллекции, надо оставить пустым параметр запроса:
db.users.remove({})
# Удаление коллекций и баз данных. Мы можем удалять не только документы, но и коллекции и базы данных. Для удаления коллекций используется функция drop:
db.users.drop()
# И если удаление коллекции пройдет успешно, то консоль выведет: true
# Чтобы удалить всю базу данных, надо воспользоваться функцией dropDatabase():
db.dropDatabase()
# Ручная установка ссылок сводится к присвоению значения поля _id одного документа полю другого документа. Допустим, у нас могут быть коллекции, представляющие компании и работников, работающих в этих компаниях. Итак, сначала добавим в коллекцию companies документ представляющий компанию:
db.companies.insert({"_id" : "microsoft", year: 1974})
# Теперь добавим в коллекцию persons документ, представляющий работника. В этом документе будет поле company, представляющее компанию, где работает работник. И очень важно, что в качестве значения для этого поля мы устанавливаем не объект company, а значение ключа _id добавленного выше документа:
db.users.insert({name: "Tom", age: 28, company: "microsoft"})
# Aвтоматическое связывание. Используя функциональность DBRef, мы можем установить автоматическое связывание между документами.
apple=({"name" : "apple", "year": 1976})
db.companies.save(apple)
# в данном случае сохранение идет с помощью метода save, не insert. Метод save при добавлении нового документа генерирует _id. И после сохранения мы можем вывести документ на консоль: > apple. Теперь создадим новый документ для коллекции person, у которого ключ company свяжем с только что добавленным документом apple:
steve = ({"name": "Steve", "age": 25, company: new DBRef('companies', apple._id)})
db.users.save(steve)
# И мы можем протестировать:
db.companies.findOne({_id: steve.company.$id})
# Формальный синтаксис DBRef следующий:
# { "$ref" : название_коллекции, "$id": значение [, "$db" : название_бд ]}

# когда коллекции содержат миллионы документов, а нам надо сделать выборку по определенному полю, то поиск нужных данных может занять некоторое время, которое может оказаться критичным для нашей задачи. В этом случае нам могут помочь индексы. Индексы позволяют упорядочить данные по определенному полю, что впоследствии ускорит поиск. Например, если мы в своем приложении или задаче, как правило, выполняем поиск по полю name, то мы можем индексировать коллекцию по этому полю.
#  с помощью метода createIndex устанавливается индекс по полю name. MongoDB позволяет установить до 64 индексов на одну коллекцию.
db.users.createIndex({"name" : 1})
# если нам потребуется, чтобы в коллекцию можно было добавлять документ с одним и тем же значением ключа только один раз, мы можем установить флаг unique:
db.users.createIndex({"name" : 1}, {"unique" : true})
# Также можно задать уникальный индекс сразу для двух полей:
db.users.createIndex({"name" : 1, "age" : 1}, {"unique" : true})
# Все индексы базы данных хранятся в системной коллекции system.indexes. Обратившись к ней, мы можем получить все индексы и связанную с ними информацию:
db.system.indexes.find()
# Также мы можем воспользоваться методом getIndexes и вывести всю информацию об индексах для конкретной коллекции:
db.users.getIndexes()
# Явное создание коллекции. В предыдущих темах коллекция создавалась неявно автоматически при добавлении в нее первых данных. Но мы также можем создать ее явным образом, применив метод db.createCollection(name, options), где name - название коллекции, а options - необязательный объект с дополнительными настройками инициализации. Например:
db.createCollection("accounts")
# Переименование коллекции
db.users.renameCollection("новое_название")
# И если переименование пройдет удачно, то консоль отобразит: {"ok" : 1}

